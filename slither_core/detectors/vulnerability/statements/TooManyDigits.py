"""
Module detecting numbers with too many digits.
"""

import re
from typing import List

from slither_core.core.cfg.node import Node
from slither_core.core.declarations.function_contract import FunctionContract
from slither_core.detectors.abstract_detector import (
    AbstractDetector,
    DetectorClassification,
    DETECTOR_INFO,
)
from slither_core.slithir.variables import Constant
from slither_core.utils.output import Output

_HEX_ADDRESS_REGEXP = re.compile("(0[xX])?[0-9a-fA-F]{40}")


def is_hex_address(value: str) -> bool:
    """
    Checks if the given string of text type is an address in hexadecimal encoded form.
    """
    return _HEX_ADDRESS_REGEXP.fullmatch(value) is not None


class TooManyDigits(AbstractDetector):
    """
    Detect numbers with too many digits
    """

    ARGUMENT = "digits-suffix"
    HELP = "Conformance to numeric notation best practices"
    IMPACT = DetectorClassification.INFORMATIONAL
    CONFIDENCE = DetectorClassification.MEDIUM

    WIKI = "https://github.com/crytic/slither/wiki/Detector-Documentation#too-many-digits"
    WIKI_TITLE = "Digits recommended suffix"

    # region wiki_description
    WIKI_DESCRIPTION = """
Literals with many digits are difficult to read and review.
"""
    # endregion wiki_description

    # region wiki_exploit_scenario
    WIKI_EXPLOIT_SCENARIO = """
```solidity
contract MyContract{
    uint 1_ether = 10000000000000000000; 
}
```

While `1_ether` looks like `1 ether`, it is `10 ether`. As a result, it's likely to be used incorrectly.
"""
    # endregion wiki_exploit_scenario

    # region wiki_recommendation
    WIKI_RECOMMENDATION = """
Use:
- [Ether suffix](https://solidity.readthedocs.io/en/latest/units-and-global-variables.html#ether-units),
- [Time suffix](https://solidity.readthedocs.io/en/latest/units-and-global-variables.html#time-units), or
- [The scientific notation](https://solidity.readthedocs.io/en/latest/types.html#rational-and-integer-literals)
"""
    # endregion wiki_recommendation
    digit_info: DETECTOR_INFO = [
        "digits recommended suffix: \n\t- ether | 10**18 | 1000000000000000000\n\t- finney | 10**15 | 1000000000000000\n\t- szabo | 10**12 | 1000000000000\n\t- gwei | 10**9 | 1000000000\n\n"]

    @staticmethod
    def _detect_too_many_digits(f: FunctionContract) -> List[Node]:
        ret = []
        pattern = r"\*\*\s*(\d+)"

        for node in f.nodes:
            # each node contains a list of IR instruction
            for ir in node.irs:
                match = re.search(pattern, str(ir))
                if match:
                    exponent = int(match.group(1))
                    if exponent >= 18:
                        ret.append({"ether": str(exponent), "node": node})
                    elif 15 <= exponent < 18:
                        ret.append({"finney": str(exponent), "node": node})
                    elif 12 <= exponent < 15:
                        ret.append({"szabo": str(exponent), "node": node})
                    elif exponent < 12:
                        ret.append({"gwei": str(exponent), "node": node})
                else:
                    # iterate over all the variables read by the IR
                    for read in ir.read:
                        # if the variable is a constant
                        if isinstance(read, Constant):
                            # read.value can return an int or a str. Convert it to str
                            value_as_str = read.original_value
                            if not is_hex_address(value_as_str):
                                if "000000000000000000" in value_as_str:
                                    ret.append(
                                        {"ether": value_as_str, "node": node})
                                elif "000000000000000" in value_as_str:
                                    ret.append(
                                        {"finney": value_as_str, "node": node})
                                elif "000000000000" in value_as_str:
                                    ret.append(
                                        {"szabo": value_as_str, "node": node})
                                elif "000000000" in value_as_str:
                                    ret.append(
                                        {"gwei": value_as_str, "node": node})
                                else:
                                    continue
        return ret

    def _detect(self) -> List[Output]:
        results = []
        #results.append(self.generate_result(self.digit_info))
        node_info: DETECTOR_INFO = []  # 초기값 설정
        for contract in self.compilation_unit.contracts_derived:
            for f in contract.functions:
                result = self._detect_too_many_digits(f)
                for res in result:
                    if "ether" in res.keys():
                        func_info: DETECTOR_INFO = [
                            f, " uses literals with too many digits: ", res["ether"], " recommended suffix: ether"]
                    elif "finney" in res.keys():
                        func_info: DETECTOR_INFO = [
                            f, " uses literals with too many digits: ", res["finney"], " recommended suffix: finney"]
                    elif "szabo" in res.keys():
                        func_info: DETECTOR_INFO = [
                            f, " uses literals with too many digits: ", res["szabo"], " recommended suffix: szabo"]
                    elif "gwei" in res.keys():
                        func_info: DETECTOR_INFO = [
                            f, " uses literals with too many digits: ", res["gwei"], " recommended suffix: gwei"]

                    node_info = func_info + ["\n\t- ", res["node"], "\n"]

                    res = self.generate_result(node_info)
                    results.append(res)
                
        return results
