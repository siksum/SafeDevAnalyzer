{
  "incorrect-shift": {
    "success": false,
    "error": [
      null
    ],
    "results": {
      "filename": "/Users/sikk/Desktop/Antibug/SafeDevAnalyzer/test/detector/shift.sol",
      "detector": "incorrect-shift",
      "impact": "High",
      "confidence": "High",
      "element": [
        {
          "type": "function",
          "name": "f",
          "line": 13,
          "code": "    function f() internal pure returns (uint a) {\n",
          "parent_type": "contract",
          "parent_name": "Bar"
        },
        {
          "type": "node",
          "name": "a = 8 >> a",
          "line": 15,
          "code": "            a := shr(a, 8)\n",
          "parent_type": "function",
          "parent_name": "f"
        }
      ],
      "info_korean": "f 함수는 잘못된 shift 연산을 포함하고 있습니다. EXPRESSION a = 8 >> a",
      "description_korean": "\n어셈블리 함수에서 shift 연산을 사용할 때, 파라미터의 순서가 잘못된 경우를 검사합니다.\n    ",
      "exploit_scenario_korean": "\n```solidity\ncontract C {\n    function f() internal returns (uint a) {\n        assembly {\n            a := shr(a, 8)\n        }\n    }\n}\n```\n`shr(a, 8)`: 변수 a의 비트를 오른쪽으로 8개만큼 시프트합니다. 즉, a의 값을 8비트 오른쪽으로 이동시킵니다.\n`shr(8, a)`: 숫자 8을 변수 a의 비트 수만큼 오른쪽으로 시프트합니다. 따라서 a 변수가 어떤 값이든 안전하게 8 비트만큼 오른쪽으로 시프트됩니다.\n    \n`shl(a, 8)`: a 변수가 시프트됩니다. a 변수의 값과 비트 길이에 따라 결과가 달라질 수 있습니다. 만약 a가 충분히 큰 값을 갖고 있어서 왼쪽 시프트로 인해 비트 길이가 넘어가는 경우, 예상치 못한 값이 발생할 수 있습니다.\n`shl(8, a)`: 8이 고정된 값을 시프트하는 것이므로 시프트 연산의 결과는 a 변수의 값에만 의존합니다. 따라서 a 변수가 어떤 값이든 안전하게 8 비트만큼 왼쪽으로 시프트됩니다.\n",
      "recommendation_korean": "\n보통은 `shl(8, a)`, `shr(8, a)`가 더 예측 가능하고 안전한 방법일 수 있습니다. 하지만 실제 상황과 사용하는 데이터에 따라서 다른 방식이 더 적합할 수 있습니다. 이러한 결정은 프로그램의 요구 사항과 목적에 따라 다르므로 주의 깊게 검토하고 적절한 방법을 선택해야 합니다.\n또한, solidity yul code는 Overflow/Underflow를 검사하지 않으므로, 이러한 케이스를 고려하여 코드를 작성해야 합니다.\n    ",
      "reference": "\n- https://ethereum.stackexchange.com/questions/127538/right-shift-not-working-in-inline-assembly\n- https://docs.soliditylang.org/en/v0.8.23/types.html#value-types:~:text=Before%20version%200.5.0%20a%20right%20shift%20x%20%3E%3E%20y%20for%20negative%20x%20was%20equivalent%20to%20the%20mathematical%20expression%20x%20/%202**y%20rounded%20towards%20zero%2C%20i.e.%2C%20right%20shifts%20used%20rounding%20up%20(towards%20zero)%20instead%20of%20rounding%20down%20(towards%20negative%20infinity).\n- https://docs.soliditylang.org/en/v0.8.23/types.html#value-types:~:text=Overflow%20checks%20are%20never%20performed%20for%20shift%20operations%20as%20they%20are%20done%20for%20arithmetic%20operations.%20Instead%2C%20the%20result%20is%20always%20truncated.    \n    "
    }
  },
  "incorrect-return": {
    "success": false,
    "error": [
      null
    ],
    "results": {
      "filename": "/Users/sikk/Desktop/Antibug/SafeDevAnalyzer/test/detector/shift.sol",
      "detector": "incorrect-return",
      "impact": "High",
      "confidence": "Medium",
      "element": [
        {
          "type": "function",
          "name": "foo",
          "line": 22,
          "code": "    function foo() public pure returns(bool) {\n",
          "parent_type": "contract",
          "parent_name": "Foo"
        },
        {
          "type": "function",
          "name": "blockingFunction",
          "line": 7,
          "code": "    function blockingFunction() public pure returns (bool) {\n",
          "parent_type": "contract",
          "parent_name": "Bar"
        },
        {
          "type": "node",
          "name": "return(uint256,uint256)(0,0x20)",
          "line": 9,
          "code": "            return(0,0x20)\n",
          "parent_type": "function",
          "parent_name": "blockingFunction"
        }
      ],
      "info_korean": "함수 foo가 함수 blockingFunction를 호출하면, EXPRESSION return(uint256,uint256)(0,0x20)으로 인해 실행 흐름이 중단됩니다.\n",
      "description_korean": "inline assembly block에 return이 사용되면 예기치 않은 실행 흐름이 중단될 수 있습니다.",
      "exploit_scenario_korean": "\n```solidity\n    contract C {\n        function f() internal returns (uint a, uint b) {\n            assembly {\n                return (5, 6)\n            }\n        }\n\n        function g() returns (bool){\n            f();\n            return true;\n        }\n    }\n```\nf 함수의 return 문은 g 함수의 실행을 중단시킵니다.\ng 함수를 호출하여 true 값을 반환할 것을 기대했으나 f 함수에서 5번째 offset부터 6바이트를 반환한 뒤 실행이 중단됩니다.",
      "recommendation_korean": "0.6.0 이상 버전부터 leave 키워드가 등장하였습니다. 만약 이전 버전을 사용한다면, 0.6.0 이상 버전으로 변경한 후, solidity의 leave 문을 사용하세요.",
      "reference": "https://blog.ethereum.org/2019/12/03/ef-supported-teams-research-and-development-update-2019-pt-2#solidity-060:~:text=Add%20%22leave%22%20statement%20to%20Yul%20/%20Inline%20Assembly%20to%20return%20from%20current%20function"
    }
  }
}