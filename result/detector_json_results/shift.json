{
  "incorrect-shift": {
    "success": false,
    "error": [
      null
    ],
    "results": {
      "filename": "/Users/sikk/Desktop/Antibug/SafeDevAnalyzer/test/detector/shift.sol",
      "detector": "incorrect-shift",
      "impact": "High",
      "confidence": "High",
      "element": [
        {
          "type": "function",
          "name": "f",
          "line": 13,
          "code": "    function f() internal pure returns (uint a) {\n",
          "parent_type": "contract",
          "parent_name": "Bar"
        },
        {
          "type": "node",
          "name": "a = 8 >>' a",
          "line": 15,
          "code": "            a := sar(a, 8)\n",
          "parent_type": "function",
          "parent_name": "f"
        }
      ],
      "info": "Bar.f() (test/detector/shift.sol#13-17) contains an incorrect shift operation: a = 8 >>' a (test/detector/shift.sol#15)\n",
      "description": "When using shift operations in an assembly function, it is important to check for cases where the parameters are in the wrong order.",
      "exploit_scenario": "\n```solidity\ncontract C {\n    function f() internal returns (uint a) {\n        assembly {\n            a := shr(a, 8)\n        }\n    }\n}\n```\n`shr(a, 8)`: Shifts the bits of variable 'a' 8 positions to the right. In other words, it moves the value of 'a' 8 bits to the right.\n`shr(8, a)`: Shifts the number 8 to the right by the number of bits in variable 'a'. This safely shifts 'a' to the right by 8 bits, regardless of its value.\n\n`shl(a, 8)`: The variable a is being shifted. The result can vary depending on the value and bit length of a. If a has a sufficiently large value such that left-shifting it would exceed the bit length, unexpected values may occur.\n`shl(8, a)`: The number 8 is a fixed value being used to perform the shift operation. Therefore, the result of the shift operation depends solely on the value of the variable a. Consequently, it's safe to perform an 8-bit left shift on a, regardless of its current value.\n\n`sar(a, 8)`: This operation shifts the bits of variable `a` to the right, so the result depends on the current value of `a`.\n`sar(8, a)`: This operation always performs a bitwise right shift by the constant value 8, regardless of the current value of variable `a`. Therefore, it provides predictable and consistent results.\n",
      "recommendation": "\nIn general, `sar(8, a)`, `shl(8, a)` and `shr(8, a)` can be more predictable and safer approaches. However, the choice of method may vary depending on the specific circumstances and the data being used. The decision should be made carefully, taking into account the requirements and goals of the program.\nFurthermore, Solidity Yul code does not check for Overflow/Underflow, so you should write your code with these cases in mind and handle them appropriately.\n",
      "reference": "\n- https://ethereum.stackexchange.com/questions/127538/right-shift-not-working-in-inline-assembly\n- https://docs.soliditylang.org/en/v0.8.23/types.html#value-types:~:text=Before%20version%200.5.0%20a%20right%20shift%20x%20%3E%3E%20y%20for%20negative%20x%20was%20equivalent%20to%20the%20mathematical%20expression%20x%20/%202**y%20rounded%20towards%20zero%2C%20i.e.%2C%20right%20shifts%20used%20rounding%20up%20(towards%20zero)%20instead%20of%20rounding%20down%20(towards%20negative%20infinity).\n- https://docs.soliditylang.org/en/v0.8.23/types.html#value-types:~:text=Overflow%20checks%20are%20never%20performed%20for%20shift%20operations%20as%20they%20are%20done%20for%20arithmetic%20operations.%20Instead%2C%20the%20result%20is%20always%20truncated.    \n    "
    }
  }
}