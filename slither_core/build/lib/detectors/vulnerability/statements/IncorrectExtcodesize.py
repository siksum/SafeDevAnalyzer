"""
Module detecting usage of extcodesize in inline assembly
"""
from typing import List, Tuple

from slither_core.core.cfg.node import Node, NodeType
from slither_core.core.declarations.contract import Contract
from slither_core.core.declarations.function_contract import FunctionContract
from slither_core.detectors.abstract_detector import (
    AbstractDetector,
    DetectorClassification,
    DETECTOR_INFO,
)
from slither_core.utils.output import Output
from slither_core.core.expressions.assignment_operation import AssignmentOperation
from slither_core.core.expressions.binary_operation import BinaryOperation


class IncorrectExtcodesize(AbstractDetector):
    """
    Detect usage of extcodesize in inline assembly
    """

    ARGUMENT = "incorrect-extcodesize"
    HELP = "Incorrect extcodesize usage"
    IMPACT = DetectorClassification.INFORMATIONAL
    CONFIDENCE = DetectorClassification.HIGH

    WIKI = "https://github.com/crytic/slither/wiki/Detector-Documentation#assembly-usage"

    WIKI_TITLE = "Incorrect extcodesize usage"
    WIKI_DESCRIPTION = "Attacker can manipulate the result of `extcodesize` in inline assembly."
    WIKI_RECOMMENDATION = "Use extcodehash instead of extcodesize"

    @staticmethod
    def _contains_inline_extcodesize_use(node: Node) -> bool:
        results = []
        if node.type == NodeType.ASSEMBLY:
           print(node.irs)
        for ir in node.irs:
            #print(ir)
            
            if isinstance(ir.expression, AssignmentOperation) and "extcodesize" in str(ir.expression.expression_right):
                results.append(ir.expression.__str__())
            elif isinstance(ir.expression, BinaryOperation) and " > 0" in str(ir.expression):
                results.append(ir.expression.__str__())

                # results.append({"expression":ir.expression.__str__(),"operation":ir.expression.__str__()})
        return results

    def detect_assembly(self, contract: Contract) -> List[Tuple[FunctionContract, List[Node]]]:
        ret = []
        for f in contract.functions_and_modifiers:
            nodes = f.nodes
            ext_nodes = [
                n for n in nodes if self._contains_inline_extcodesize_use(n)]
            if ext_nodes:
                ret.append((f, ext_nodes))
        return ret

    def _detect(self) -> List[Output]:
        """Detect the functions that use inline assembly"""
        results = []
        for c in self.contracts:
            values = self.detect_assembly(c)
            for func, nodes in values:
                info: DETECTOR_INFO = [
                    func, " uses extcodesize for contract size check. Use extcodehash instead of extcodesize.\n"]

                # sort the nodes to get deterministic results
                nodes.sort(key=lambda x: x.node_id)

                for node in nodes:
                    info += ["\t- ", node, "\n"]

                res = self.generate_result(info)
                results.append(res)

        return results