<button class='date-button'>2024-08-14</button>

# Audit Report

> üîç `Filename`: /Users/sikk/vscode-extension-antibug/SafeDevAnalyzer/test/EtherStore.sol
---

[<button class='styled-button'>Korean</button>](EtherStore_kr.md)
<br />


<style>
    .date-button{
        color:black;
        border:none;
        font-weight: bold;
        background-color: sand;
        width: 150px;
        height: 25px;
        float: right;
        border-radius: 20px;
    }
    .styled-button{
        color: black;
        border: none;
        font-weight: bold;
        background-color: lightskyblue;
        width: 100px;
        height: 30px;
        float: right;
        border-radius: 20px;
    }
    .styled-button:hover{
        color: black;
        border: none;
        font-weight: bold;
        background-color: pink;
        width: 100px;
        height: 30px;
        float: right;
        cursor: pointer;
    }
</style>

               
<details>
<summary style='font-size: 20px;'>weak-prng</summary>
<div markdown='1'>

## Detect Results

| Detector | Impact | Confidence | Info |
|:---:|:---:|:---:|:---:|
| weak-prng | <span style='color:lightcoral'> High </span> | <span style='color:olivedrab'> Medium </span> | EtherStore.guess(uint256) (EtherStore.sol#24-32) uses a weak PRNG: "_guess == answer (EtherStore.sol#29)" 
 |||


<br />

## Vulnerabiltiy in code:

```solidity
line 24:     function guess(uint _guess) public {

```
 ---

 ```solidity
line 29:         if (_guess == answer) {

```
 ---

 <br />

## Background:


<details> 
    <summary style='font-size: 18px;color:pink;'> üí° What is Randomness in Blockchain? </summary><br />
    
- Randomness in blockchain can be categorized into two types: pseudo-randomness and true randomness.
    - Pseudo-randomness is generated by deterministic algorithms, and if you know the initial seed value, it can be predicted. 
    - True randomness relies on entropy sources and generates random values that are unpredictable.

- Nodes in a blockchain network can generate pseudo-randomness using various algorithms, and this randomness is used in scenarios such as selecting lottery winners, distributing rewards, determining the rarity of NFT token items in games, and distributing loot.
- However, blockchain ensures that all nodes in the network reach the same conclusion, so if the same input is provided, the output of a contract will always be the same.   

</details>
<br />     
    

<br />

## Description:


In blockchain, it is not possible to generate true randomness. 
The absence of true randomness means that the results of random number generation can be predicted, allowing for manipulation.

True randomness relies on unpredictable external factors such as atmospheric noise or user actions, but smart contracts do not have direct access to such factors, making it impossible to generate true randomness. 


This limitation is particularly important when smart contracts are used for security mechanisms like private key generation, as attackers could potentially predict the private keys and gain unauthorized access to accounts or funds.

There are two main methods for generating random numbers in blockchain:

<details> 
    <summary style='font-size: 16px;color:skyblue;'> 1. Using Randomness from the Blockchain Network Nodes </summary><br />

Blockchain networks provide certain variables in each block, such as 
   
|  |  |  |
---|---|---
`block.basefee(uint)`|`block.chainid(uint)`|`block.coinbase()`
`block.difficulty(uint)`|`block.gaslimit(uint)`|`block.number(uint)`
`block.timestamp(uint)`|`blockhash(uint)` 

   
Among these, `block.difficulty`, `blockhash`, `block.number`, and `block.timestamp` are commonly used for random number generation.


[Solidity Docs](https://docs.soliditylang.org/en/latest/units-and-global-variables.html#block-and-transaction-properties "Reference")

Randomness generated based on block data can limit the ability of typical users to predict the random numbers, but malicious miners can potentially manipulate block data to influence the generated randomness. 

Block data remains the same for a given block, meaning that generating randomness from the same block will always produce the same result.
</details>
<br />

<details> 
    <summary style='font-size: 16px;color:skyblue;'> 2. Using External Random Number Generators </summary><br />

   Blockchain oracles can be used to generate random number seeds, and off-chain data can be obtained on-chain using on-chain oracles. 
   External randomness sources, such as API data, can be fetched and used to influence contract behavior. 
   
   This can increase unpredictability compared to generating randomness using blockchain variables, but it may introduce trust issues related to the oracle's reliability.
</details>
<br />
    

<br />

## Recommendation:


- It is advisable not to use `block.hash` and `block.timestamp` as sources for random number generation.
- Utilizing a `Commit-Reveal Scheme,` where participants commit values in advance and all commits are submitted before the actual values are revealed, is a good approach for generating randomness.
- Using decentralized solutions like `Chainlink VRF (Verifiable Random Function)` that leverage multiple inputs to generate random numbers is recommended.
- Employing hardware random number generators (RNG) to produce unpredictable, truly random values is a secure choice, making it difficult for attackers to predict the outcome.    
    
    

<br />

## Exploit scenario:


```solidity
contract GuessTheRandomNumber {
    constructor() payable {}
    function guess(uint _guess) public {
        uint answer = uint(
            keccak256(abi.encodePacked(blockhash(block.number - 1), block.timestamp))
        );
 
        if (_guess == answer) {
            (bool sent, ) = msg.sender.call{value: 1 ether}("");
            require(sent, "Failed to send Ether");
        }
    }
 }
```
 
- If you are generating random numbers by combining the `blockhash` and `block.timestamp` of the previous block as a seed, this is used in a contract where users can guess a number, and if their guess matches the generated number, they win `1 ether`. 
- While it may seem like randomness has been introduced, it's important to note that it can still be manipulated. 

```solidity
contract Attack {
    receive() external payable {}

    unction attack(GuessTheRandomNumber guessTheRandomNumber) public {
        uint answer = uint(
            keccak256(abi.encodePacked(blockhash(block.number - 1), block.timestamp))
        );
 
        guessTheRandomNumber.guess(answer);
    }
 
    function getBalance() public view returns (uint) {
        return address(this).balance;
    }
 }
```    

- The attacker deploys the `Attack` contract by providing the address of the `GuessTheRandomNumber` contract. 
- In the `attack` function, the attacker replicates the guessing logic of the `GuessTheRandomNumber` contract, using the same method of combining the `blockhash` and `block.timestamp` of the previous block as a seed to generate random numbers.

- Since the `GuessTheRandomNumber` contract's `guess` function is executed in the same block, the values of `block.number` and `block.timestamp` remain unchanged within that block. 
- This allows the attacker to generate the same random number and, as a result, claim the `1 ether` prize.


<br />

## Real World Examples:


1. `SmartBillions ICO (2017)`: SmartBillions was an Ethereum-based lottery platform where an attacker was able to manipulate the lottery game's results to claim prizes fraudulently.
    https://etherscan.io/address/0x5ace17f87c7391e5792a7683069a8025b83bbd85
    https://www.reddit.com/r/ethereum/comments/74d3dc/smartbillions_lottery_contract_just_got_hacked/   
     
2. `Fomo3D (2018)`: Fomo3D was an Ethereum smart contract-based game where an attacker could manipulate the game's outcome to dishonestly win prizes.
    https://etherscan.io/address/0xa62142888aba8370742be823c1782d17a0389da1
    https://medium.com/@zhongqiangc/randomness-in-smart-contracts-is-predictable-and-vulnerable-fomo3d-part-1-4d500c628191
    

<br />

## Reference:


- https://www.slowmist.com/articles/solidity-security/Common-Vulnerabilities-in-Solidity-Randomness.html
- https://medium.com/@solidity101/100daysofsolidity-072-source-of-randomness-in-solidity-smart-contracts-ensuring-security-and-7af014bfac22
- https://dev.to/natachi/attack-vectors-in-solidity-09-bad-randomness-also-known-as-the-nothing-is-secret-attack-ca9
- https://medium.com/rektify-ai/bad-randomness-in-solidity-8b0e4a393858
    

</details>

<details>
<summary style='font-size: 20px;'>tx-origin</summary>
<div markdown='1'>

## Detect Results

| Detector | Impact | Confidence | Info |
|:---:|:---:|:---:|:---:|
| tx-origin | <span style='color:olivedrab'> Medium </span> | <span style='color:olivedrab'> Medium </span> | `onlyOwner` uses `tx.origin` for authorization: require(bool,string)(tx.origin == owner,Not owner) (EtherStore.sol#10)
 |||


<br />

## Vulnerabiltiy in code:

```solidity
line 10:         require(tx.origin == owner, "Not owner");

```
 ---

 <br />

## Background:


<details> 
    <summary style='font-size: 18px;color:pink;'> üí° tx.origin and  msg.sender </summary><br />
    
`tx.origin` and `msg.sender` are global variables in Solidity, both representing the address of the caller.

`tx.origin` indicates the address of the account that originally created and transmitted the transaction to the network. <br>
Thus, `tx.origin` always represents the address of an `Externally Owned Account (EOA)`.<br>
It is useful when writing smart contracts that need to identify the original initiator of a transaction, such as in the implementation of multi-signature wallets.

`msg.sender` represents the address of the account that called the currently executing function. <br>
Therefore, `msg.sender` can be either the address of an `EOA` or a `Contract`. <br>
It is useful when writing smart contracts that need to verify the current sender of the message, such as in the implementation of access control features.

<br>

<div class='mermaid'>
flowchart LR
     id1(EOA) --> id2(Contract A) --> id3(Contract B) --> id4(Contract C)
</div>

<br>

If `EOA` calls `Contract A`, `Contract A` calls `Contract B`, and `Contract B` in turn calls `Contract C`, then within `Contract C`, `msg.sender` will be `Contract B`, and `tx.origin` will be `EOA`. <br>
While `msg.sender` and `tx.origin` might appear to represent the same account, `tx.origin` does not represent the address of the caller, but rather the address of the account that originally initiated the contract call.

</details>
<br />
    
    

<br />

## Description:


`tx.origin` can only track the information of the account that originally initiated the transaction.<br>
In complex transactions involving multiple contract calls, there are scenarios where it's necessary to identify the address of the `EOA`.<br>
In such cases, `tx.origin` cannot be used to identify the address of the `EOA`, preventing the implementation of granular access control based on immediate contract interactions.<br>

Additionally, using `tx.origin` for authentication is vulnerable to phishing attacks.    

<p align="center">
<img src="https://i.imgur.com/FGDediO.png" width="700" height="500">
</p>

Attackers can create malicious contracts and entice users to call these contracts. <br>
When a user interacts with a malicious contract, the attacker can capture the user's `EOA (Externally Owned Account)` address. <br>
Subsequently, if the attacker uses the user's `EOA` address to call a contract, `tx.origin` will still point to the user's address, thus mistakenly recognizing the attacker as a legitimate user.<br>
    

<br />

## Recommendation:


Using `tx.origin` limits interoperability between contracts because a contract that uses `tx.origin` cannot be safely used by another contract. <br>
Additionally, according to an answer by `Vitalik Buterin` on [ethereum stackexchange](https://ethereum.stackexchange.com/questions/196/how-do-i-make-my-dapp-serenity-proof/200#200) in July 2016, there is a possibility that `tx.origin` may be removed in future Ethereum protocol updates.<br>

It is safer to perform authentication using `msg.sender` instead of `tx.origin`, as follows.

```solidity
function transfer(address payable _to, uint256 _amount) public {
  require(msg.sender == owner);

  (bool sent, ) = _to.call.value(_amount)("");
  require(sent, "Failed to send Ether");
}
``` 
    

<br />

## Exploit scenario:


```solidity
contract Wallet {
    address public owner;

    constructor() payable {
        owner = msg.sender;
    }

    function transfer(address payable _to, uint _amount) public {
        require(tx.origin == owner, "Not owner");

        (bool sent, ) = _to.call{value: _amount}("");
        require(sent, "Failed to send Ether");
    }
}
```    

Assuming that `Alice` deploys a `Wallet` contract, and a malicious user, `Bob`, deceives `Alice` into calling his `Attack` contract.

<br>

```solidity
contract Attack {
    address payable public owner;
    Wallet wallet;

    constructor(Wallet _wallet) {
        wallet = Wallet(_wallet);
        owner = payable(msg.sender);
    }

    function attack() public {
        wallet.transfer(owner, address(wallet).balance);
    }
}
```

When `Alice` calls the `attack` function of the `Attack` contract, this `Attack` contract then calls the `transfer` function of the `Wallet` contract. <br>
The `transfer` function in the `Wallet` contract performs authentication using `tx.origin`, which points to `Alice`'s address. <br>
Therefore, the `Attack` contract is recognized as an `EOA` with `Alice`'s address, allowing Bob to withdraw Ether from Alice's `Wallet` contract.<br>
 
    

<br />

## Reference:


- https://ethereum.stackexchange.com/questions/1891/whats-the-difference-between-msg-sender-and-tx-origin
- https://docs.soliditylang.org/en/v0.8.17/security-considerations.html#tx-origin
- https://stackoverflow.com/questions/73554510/msg-sender-preferred-over-tx-origin-in-solidity
- https://consensys.github.io/smart-contract-best-practices/development-recommendations/solidity-specific/tx-origin/
- https://dev.to/zenodavids/avoiding-security-vulnerabilities-the-txorigin-vs-msgsender-debate-24an    
    

</details>

