"""
Module detecting suicidal contract

A suicidal contract is an unprotected function that calls selfdestruct
"""
from typing import List
from slither_core.core.cfg.node import Node
from slither_core.core.declarations.contract import Contract
from slither_core.core.declarations.function_contract import FunctionContract
from slither_core.detectors.abstract_detector import (
    AbstractDetector,
    DetectorClassification,
    DETECTOR_INFO,
)
from slither_core.utils.output import Output
import slither_core.slithir.operations as solc_ast


class Suicidal(AbstractDetector):
    """
    Unprotected function detector
    """

    ARGUMENT = "suicidal"
    HELP = "Functions allowing anyone to destruct the contract"
    IMPACT = DetectorClassification.HIGH
    CONFIDENCE = DetectorClassification.HIGH

    WIKI = "https://github.com/crytic/slither/wiki/Detector-Documentation#suicidal"

    WIKI_TITLE = "Suicidal"
    WIKI_DESCRIPTION = "Unprotected call to a function executing `selfdestruct`/`suicide`."

    # region wiki_exploit_scenario
    WIKI_EXPLOIT_SCENARIO = """
```solidity
contract Suicidal{
    function kill() public{
        selfdestruct(msg.sender);
    }
}
```
Bob calls `kill` and destructs the contract."""
    # endregion wiki_exploit_scenario

    WIKI_RECOMMENDATION = "Protect access to all sensitive functions."

    @staticmethod
    def detect_suicidal_func(func: FunctionContract) -> bool:
        """Detect if the function is suicidal

        Detect the public functions calling suicide/selfdestruct without protection
        Returns:
            (bool): True if the function is suicidal
        """
        if func.is_constructor:
            return False

        if func.visibility not in ["public", "external"]:
            return False

        calls = [c.name for c in func.internal_calls]
        if not ("suicide(address)" in calls or "selfdestruct(address)" in calls):
            return False
        return True

    def contains_ownership_check(self, functions: FunctionContract) -> bool:
        ret = []
        condtional_nodes = [
            n for n in functions.nodes if not (n.contains_if() or n.contains_require_or_assert())
        ]
        if condtional_nodes:
            bad_tx_nodes = self._ownership_check(functions)
        if bad_tx_nodes is True:
            ret.append((functions.name, bad_tx_nodes))

        return ret

    def _ownership_check(self, functions: FunctionContract) -> bool:
        variable_name = ""
        if functions.is_protected():
            return False
        else:
            for node in functions.nodes:
                for ir in node.irs:
                    if isinstance(ir, solc_ast.Assignment) and str(ir.rvalue) == "msg.sender":
                        for written in node._local_vars_written:
                            variable_name = written.name
                    elif isinstance(ir, solc_ast.Binary):
                        for variable in ir._variables:
                            if variable_name is str(variable) and variable_name in str(ir.expression):
                                print(
                                    f"msg.sender using in {variable_name}")
                                return False
                    else:
                        return True
        return True

    def detect_suicidal(self, contract: Contract) -> List[FunctionContract]:
        results = []
        for f in contract.functions_declared:
            if self.detect_suicidal_func(f):
                result = self.contains_ownership_check(f)
                if result:
                    results.append(result)
        return results

    def _detect(self) -> List[Output]:
        """Detect the suicidal functions"""
        results = []
        for c in self.contracts:
            values = self.detect_suicidal(c)
            for value in values:
                for func, value_type in value:
                    if value_type is True:
                        info: DETECTOR_INFO = [
                            func, " allows anyone to destruct the contract", "\n"]
                        res = self.generate_result(info)
                        results.append(res)

        return results
